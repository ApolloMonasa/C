//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
//#include <string.h>
//#include <Windows.h>
///【7.0】.嵌套调用和链式访问
///【7.1】.嵌套调用
///嵌套调用就是函数之间的互相调用，函数可以你用我我用你，但是不能在一个函数里面定义其他函数。
///【例子】计算某年某月有几天
/// 31,28,31,30,31,30,31,31,30,31,30,31
///    29

//_Bool is_the_year_leap(int year)
//{
//	if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)//还可以直接返回这个条件语句啊
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}
//int get_days_of_month(int y, int m)
//{
//	int day[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };//这样初始化可以让下标和月份对应
//	int d = day[m];
//	_Bool choice = is_the_year_leap(y);
//	if (choice&&m==2)
//	{
//		d++;
//	}
//	return d;
//}
//int main()
//{
//	int year = 0, month = 0;
//	scanf("%d %d", &year, &month);
//
//	int day = get_days_of_month(year, month);
//	printf("%d\n", day);
//
//	return 0;
//}

///【7.2】.链式访问
/// 所谓的链式访问就是将一个函数的返回值作为另一个函数的参数，像链条一样将函数串起来。

//int main()
//{
//	size_t len = strlen("abcd");
//	printf("%d", len);
//
//	return 0;
//}

//int main()
//{
//	printf("%d", printf("%d", printf("%d", 43)));
//	return 0;
//}

///【8.0】.函数的声明和定义
///【8.1】.单个文件
////声明
//_Bool is_the_year_leap(int year);
//
//int main()
//{
//	int y = 0;
//	scanf("%d", &y);
//	//调用
//	if (is_the_year_leap(y))
//		printf("yes");
//	else
//		printf("no");
//	return 0;
//}
//
////定义
//_Bool is_the_year_leap(int year)
//{
//	return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
//
//}

//函一定要先声明再使用，函数定义也是一种特殊的声明，只要在使用之前声明都行。
//【8.2】.多个文件
// 然而，值得一提的是，在真实的开发场景中，我们会把函数的声明写在一个头文件中（以add.h为例）把函数的定义写在一个c的文件中（add.c)，用的时候就#include "add.h"，注意是用""。
//这样的好处包括：方便协作，模块化，方便复用，一定程度对代码进行隐藏。

/// 【8.3】static和extern
/// 二者都是C语言中的关键字。
/// static是静态的意思，可以用来：修饰全局和局部变量，修饰函数。
/// extern是用来声明外部符号的。
/// 
/// 在讲解他们之前，需要明白什么是作用域和生命周期。
/// 【作用域】（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效（可用）的，而限定这个名字的可用性的代码范围就是这个名字的作用域。
/// 【1】局部变量的作用域是变量所在的局部范围
/// 【2】全局变量的作用域是整个工程（项目）
/// 【生命周期】指的是变量的创建（申请内存）到变量的销毁（收回内存）之间的一个时间段。
/// 【1】局部变量的生命周期是：进入作用域变量创建，生命周期开始，出作用域生命周期结束。
/// 【2】全局变量的生命周期是：整个程序的生命周期。
/// 【8.3.1】.static
//（1）修饰局部变量
//void test()
//{
//	int a = 5;
//	//static int a = 5;//做个实验，发现static可以让变量的生命周期延长，一直沿用，不会销毁。
//	//实际上这条语句不会被反汇编，因为在编译时就为他指定空间了，程序运行的时候就跳过这条语句。
//	//【结论】：static修饰局部变量改变了变量的生命周期，生命周期改变的本质是改变了变量的储存类型，本来一个局部变量是存储在内存的栈区的，但是static修饰后存储到了静态区。
//	//存储在静态区的变量和全局变量是一样的（指生命周期，作用域是不会变的）。
//
//	a++;
//	printf("%d ", a);
//}
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 6; i++)
//	{
//		test();
//	}
//	return 0;//666666
//}

//（2）修饰全局变量（此处所用全局变量定义在test.c中）
//声明：
//extern int global;
//int main()
//{
//	printf("%d", global);
//	return 0;
//}
//【结论】一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用，不能在其他源文件中使用。
//本质原因是全局变量默认是具有外部链接属性的，在外部的文件中想使用，只需要适当的声明就可以使用；
//但是全局变量被static修饰后，外部链接属性就变成了内部链接属性，只能在自己所在的源文件内部 使用了，其他源文件即使声明了也是无法正常使用的。

//（3）修饰函数//和修饰全局变量相似
//extern int Add();
//int main()
//{
//	int a = 5, b = 2;
//	int c = Add(a, b);
//	printf("%d\n", c);
//	return 0;
//}

/// 【8.3.2】.extern
////声明：
//extern int global;
//int main()
//{
//	printf("%d", global);
//	return 0;
//}
