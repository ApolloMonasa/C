//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
///第12讲 深入理解指针（2）
///【1.0】数组名的理解
/// 数组名本身就是数组首元素的地址，即arr==&arr[0]，你更乐意用哪个呢？
/// 没啥好讲的，代码都懒得给，唯一值得一提的是，在sizeof()和&面前这个理解就不适合了
/// 
/// sizeof计算的是整个数组的大小，单位是字节，这里的数组名代表整个数组。
/// 
/// &取出的是【整个数组的地址】，整个数组的地址和数组首元素的地址是有区别的；
/// 类型不同，&arr是int(*)[10],arr和&arr[0]是int*,这就导致了二者在进行【指针+-整数】运算的时候，基本单位不同。
/// 
//int main()
//{
//	int arr[10] = { 0 };
//	printf("&arr   =%p\n", &arr);
//	printf("&arr+1 =%p\n",&arr+1 );//跳过40字节
//
//	printf("&arr[0]  =%p\n", &arr[0]);
//	printf("&arr[0]+1=%p\n",&arr[0]+1);//跳过4字节
//
//	printf("arr   =%p\n", arr);
//	printf("arr+1 =%p\n",arr+1 );//跳过4字节
//	return 0;
//}
/// 
/// 不能通过&arr的解引用来获取数组内的内容
/// 
/// （但是实际上内存中地址实际上是相同的）
/// 【2.0】使用指针访问数组
/// 
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int* p = arr;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//输入
//	//for (; i < sz; i++)
//	//{
//	//	scanf("%d", &arr[i]);
//	//}
//	for (; i < sz; i++)
//		scanf("%d", (p + i));
//	//输出
//	//for (i = 0; i < sz; i++)
//	//{
//	//	printf("%d ", arr[i]);
//	//}
//	for (i=0; i < sz; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//
//
//	return 0;
//}
///arr[i]和*(arr+i)完全等价
/// 但是前者编译器在执行的时候，也会转换成后者来执行。
/// 
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		//printf("%d ", arr[i]);
//		//printf("%d ", *(arr + i));
//		//printf("%d ", *(i + arr));
//		printf("%d ", i[arr]);//匪夷所思的写法，但是你会发现这个[]只是操作符，这个操作符就是等价于*( + )而已，不推荐，但是可以了解
//	}
//
//	return 0;
//}
/// 
/// 【3.0】一维数组传参的本质
/// 

//void test(int arr[])//这个参数的[]里面写不写，写什么都无所谓
//{
//	int sz2 = sizeof(arr) / sizeof(arr[0]);
//	printf("sz2 = %d\n", sz2);
//}
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz1 = sizeof(arr) / sizeof(arr[0]);
//	printf("sz1 = %d\n", sz1);
//	test(arr);
//	return 0;
//}
///为什么一样的表达式结果不一样？
/// 这就涉及到一维数组传参的本质：它传递的是首元素地址，x86环境下其大小是4字节，除一个整型的大小你觉得呢？
/// 这也解释了为什么形参数组大小可以省略或者乱写：
/// 1.数组的形参的部分是不会真实创建数组的，那么就不需要数组大小
/// 2.函数形参部分应该使用指针变量来接收啊，如int*____
/// 【总结】一维数组传参的时候，形参可以写成数组的方式，主要是为了方便理解和使用，但是也可以写成指针，并且这才是其本质。
/// 并且一般如果要遍历数组，还要传入数组元素个数
/// 
/// 【4.0】冒泡排序--对数字进行排序
/// 【核心思想】：相邻元素两两比较,一个轮回确定一个位置。
/// 【效率】：排列n个数字，要经历n-1个轮回；
/// 
////排序函数
//void buble_sort(int arr[],int sz)
//{
//	int i = 0,j = 0;
//	//轮回数是sz-1
//	for (i = 0; i < sz - 1; i++)
//	{
//		int count = 0;//这个count是用来优化的，让它不必进行无效比较
//		for (j = 0; j < sz - i - 1; j++)
//		{
//			if (arr[j + 1] < arr[j])
//			{
//				int temp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = temp;
//				count += 1;
//			}
//		}
//		if (count == 0)
//			break;
//	}
//}
////打印函数
//print(int arr[], int sz)
//{
//	
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);//或许学到这里会有疑惑,不是说传进来的只是数组首元素的地址吗？怎么地址还可以用数组元素访问操作符？
//		///那我们其实也讲过：[]也可以理解成*( + )
//	}
//	printf("\n");
//}
//int main()
//{
//	int arr[] = { 10,1,2,3,4,5,6,7,8,9 };
//	//写一个函数，完成对arr数组的升序排序
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//先打印排序前的
//	print(arr, sz);
//
//	buble_sort(arr, sz);
//
//	print(arr, sz);
//
//
//	return 0;
//}

///拓展：插入排序；选择排序；快速排序；归并排序。
/// 【5.0】二级指针
/// 有点俄罗斯套娃的味道了
//int main()
//{
//	int a = 10;
//	int* p = &a;
//	printf("%d\n", *p);
//	int** pp = &p;
//	printf("%d\n", **pp);
//	int*** ppp = &pp;
//	printf("%d\n", ***(ppp));
//	return 0;
//}
/// 【6.0】指针数组
/// 顾名思义，就是存放指针的数组
//int main()
//{
//	int a = 0, b = 0, c = 0;
//	int* arr[10] = { &a,&b,&c };
//	char* arr2[3];
//
//	return 0;
//}
/// 【7.0】指针数组模拟二维数组
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//	int* arr[] = { arr1,arr2,arr3 };
//	printf("%d", arr[0][0]);//看起来是不是跟二维数组调用一模一样呢？
//	return 0;
//}
