//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
///第10讲  操作符详解
/// 
/// 【1.0】操作符分类
/// 算术操作符 + - * / %
/// 移位操作符 << >>
/// 位操作符 & | ^
/// 赋值操作符  <<=  >>=  &=  |=  ^=  = += -= /= *= %=
/// 单目操作符++ --  !  &  *  +  ~  sizeof(类型)
/// 关系操作符  >  <  ==   <=  >=  !=
/// 逻辑操作符  &&  ||
/// 条件操作符（三目）  ? :
/// 逗号表达式,
/// 下标引用[]
/// 函数调用()
/// 结构成员访问  .  ->
/// 【2.0】二进制和进制转换
/// 0开头8进制//0x开头16进制
/// 进制转换有脑就行
/// 【3.0】原码、反码、补码
/// 整数的二进制表示方法有三种，即原码，反码和补码
/// 有符号整数的三种表示形式均有【符号位】和【数值位】两部分，二进制序列中，最高位的1位被当作符号位，剩余的都是数值位。（符号位0+1-）
/// 【ex】int a = -7||==>>1(符号-) 1000000000000000000000000000111---原码
///                       1(符号-) 1111111111111111111111111111000---反码
///                       1(符号-) 1111111111111111111111111111001---反码+1==补码
/// 【正整数的三码同（无符号相当于正整数），负整数三码各不相同】
/// 对于整型来说，数据存放在内存中的其实是补码
/// 为什么？
/// 在计算机系统中，数值一律用补码来表示和储存。原因在于，使用补码，可以将符号位和数值位统一处理；把加法和减法统一处理（CPU只有加法器）此外补码和原码相互转换的运算过程相同，不需要额外的硬件电路。
/// 【4.0】移位操作符  <<  >>
/// 【注意】操作数只能是整数
/// 【4.1】左移操作符
/// 移位规则：左边抛弃，右边补0
//左移--移动的是二进制序列
//12----00000000 00000000 000000000 00001100
//结果--00000000 00000000 000000000 00011000==24
// 【注意】移位操作符不会改变n，要改变就要<<=
//int main()
//{
//	int n = 12;//那-10呢（涉及原码反码补码）
//	int m =n << 1;
//	printf("%d", m);
//	printf("%d", n);
//	return 0;
//}
///【4.2】.右移操作符
///移位规则：首先右移运算分两种：
/// 1.逻辑右移：左边用0填充，右边丢弃
/// 2.算术右移：左边用该值的符号位填充，右边丢弃
/// 到底采用哪种，取决于编译器，但是大部分都是算数右移！
//int main()
//{
//	int a = -10;
//	int b = a >> 1;
//	//-10
//	//10000000 00000000 00000000 00001010
//	//11111111 11111111 11111111 11110101
//	//11111111 11111111 11111111 11110110
//	//[逻辑]01111111 11111111 11111111 11111011--特大
//	//[算数]11111111 11111111 11111111 11111011--10000000 00000000 00000000 00000101-- -5
//	printf("%d\n", a);
//	printf("%d\n", b);
//	return 0;
//}
//【现象】右移除2，左移乘2
//【注意】移位不要移动负数位，这个是标准未定义的行为

/// 【5.0】位操作符：& | ^ ~
/// 位操作符有：（这个位指二进制位）【他们的操作数只能是整数】
/// 【&  按位与】
/// 对于的二进制位相与，有0为0，无0为1；

//int main()
//{
//	int a = -5;
//	int b = 13;
//
//	int c = a & b;
//	//a--10000000 00000000 00000000 00000101--补码11111111 11111111 11111111 11111011
//	//b--00000000 00000000 00000000 00001101--补码00000000 00000000 00000000 00001101
//	//                                            00000000 00000000 00000000 00001001--9
//	printf("%d", c);
//	return 0;
//}
/// 【|  按位或】
/// 
//int main()
//{
//	int a = -5, b = 13;
//	int c = a | b;
//	//	//a--10000000 00000000 00000000 00000101--补码11111111 11111111 11111111 11111011
//    //	//b--00000000 00000000 00000000 00001101--补码00000000 00000000 00000000 00001101 
//	//                                                11111111 11111111 11111111 11111111
//	//                                                10000000 00000000 00000000 00000001-- -1                            
//	printf("%d", c);
//	return 0;
//}

/// 【^  按位异或】
//相同为0相异为1

//int main()
//{
//	int a = -5, b = 13;
//	int c = a ^ b;
//	//	//a--10000000 00000000 00000000 00000101--补码11111111 11111111 11111111 11111011
//	//	//b--00000000 00000000 00000000 00001101--补码00000000 00000000 00000000 00001101 
//	//                                                11111111 11111111 11111111 11110110
//	//                                                10000000 00000000 00000000 00001010-- -10                            
//	printf("%d", c);
//	return 0;
//}


/// 【~  按位取反】
 
//int main()
//{
//	int a = 0;
//	printf("%d", ~a);
//	//0000000000000000000000000000000000
//	//1111111111111111111111111111111111
//	//1000000000000000000000000000000001-- -1
//	return 0;
//}
 
//一道变态面试题：
//不能创建临时变量(第三个变量)，实现两个整数的交换
//int main()
//{
//	int a = 10;
//	int b = 20;
//	printf("交换前：a=%d,b=%d\n", a, b);
//	//【1】(问题是a+b可能过大导致溢出)
//	//a += b;
//	//b = a - b;
//	//a = a - b;
//	//printf("交换后：a=%d,b=%d\n", a, b);
//	//【2】（不可能溢出）
//	//[解释]a^a=0;a^0=a，异或支持交换律
//	a = a ^ b;
//	b = a ^ b;//=a^b^b=a^0=a
//	a = a ^ b;//同理
//	return 0;
//}

//【练习1】编写代码实现：求一个整数存储在内存中的二进制中1的个数
//int main()
//{
//	int n = 13;
//	int count = 0;
//	while (n)
//	{
//		if (n % 2 == 1)
//			count++;
//		n /= 2;
//	}
//	printf("%d", count);
//	return 0;
//}//对负数有问题

//【补充技巧】给一个数字按位与上一个1就可以得到二进制最低位上的数,[易错点]移位操作符不会改变操作数的值

//int main()
//{
//	int n = -1;
//	int count = 0;
//	for (int i = 0; i < 32; i++)
//	{
//		
//		if (((n >> i) & 1) == 1)
//			count++;
//		
//	}
//	
//	printf("%d", count);
//	return 0;
//}

//改进
//【须知】n=n&(n-1)让n二进制序列最右边的1消失
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int count = 0;
//	while (n)
//	{
//		n = n & (n - 1);
//		count++;
//	}
//	printf("%d", count); 
//	return 0;
//}

//[出题]写一个代码，判断n是不是2的次方数（判断是不是二进制序列中只有一个1）
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	if ((n & (n - 1)) == 0)//不知道为何这里判断符左边必须用括号
//		printf("yes\n");
//	else
//		printf("no\n");
//	return 0;
//}

//【练习2】二进制位置0或者置1：编写代码将13二进制序列的第五位修改为1.然后再改回0.
//int main()
//{
//	int n = 13;
//	//00000000000000000000000000001101
//	// 按位或
//	//00000000000000000000000000010000
//	n |= (n | (1 << 4));
//	printf("%d\n", n);
//	//改回去
//	//按位与
//	//11111111111111111111111111101111
//	n &= (~(1 << 4));
//	printf("%d\n", n);
//	return 0;
//}
//单片机，嵌入式开发日常操作而已

/// 【6.0】单目操作符
///！、++、--、&、*、+、-、~、sizeof、()
/// 除了& *都讲过，后面再讲

/// 【7.0】逗号表达式
/// 顾名思义，就是用逗号隔开的多个表达式，从左往右依次执行，整个表达式的结果是最后一个表达式的结果。
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1,a<b);//逗号表达式
//	printf("%d", c);
//	return 0;
//}
//可以和while连用防止冗余。

/// 【8.0】 下标访问[]，函数调用()
/// 用过了都，只需要理解操作数包括参数和名
/// 【9.0】结构成员访问操作符
/// 【9.1.0】结构体
/// C语言已经提供了内置类型，如：char，short，int，long，float，double，等等，但是只有这些内置类型还是不够的，假设我想描述学生，描述一本书，这时候单一的内置类型是不行的。
/// C语言为了解决这个问题，增加了结构体这种自定义的数据类型，让程序员可以自己创造适合的类型。
/// 结构体是一些值的集合，这些值称为成员变量。结构体的每个成员都可以是不同类型的变量，甚至是其他结构体。
/// 【9.1.1】结构的声明，定义，初始化
//struct tag
//{
//	member_list;
//}variable-list

//struct B
//{
//	char c;
//	int i;
//};
//
//struct Stu
//{
//	char NAME[20];//学生有名字，年龄，分数
//	int age;
//	float score;
//	struct B bb;
//}s5,s6,s7;//全局变量
//struct Stu s4;
//
//int main()
//{
//	struct Stu s1 = { "张三",20,95.5f,{'c',20}};//初始化，可以乱序，但要指明,(结构体要用{})
//	struct Stu s2 = {.age=18,.NAME="李四",.score=94.5f};
//	struct Stu s3;
//	printf("%s\n", s1.NAME);//结构体成员访问操作符[.]
//	printf("%d\n", s1.bb.i);
//
//	return 0;
//}

//【9.2.2】.结构体成员的间接访问【涉及指针】
/// 【10.0】操作符的属性：优先级、结合性
/// 【10.1】.优先级
/// 优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行，各种运算符的优先级是不一样的。
/// 比如*/比+-的优先级高，详见网站
/// 【10.2】结合性
/// 如果两个运算符优先级相同，就要看结合性了，根据运算符是左结合还是右结合，决定执行顺序，大部分运算符是左结合（从左往右执行），少数（如=）是右结合。
/// 参看网站：https://zh.cppreference.com/w/c/language/operator_precedence
/// 【11.0】表达式求值
/// 【11.1】.【整型提升】
/// C语言中整型算数运算总是至少以缺省（默认）整型类型的精度来进行的。
/// 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换被称为整型提升。
/// 【意义】表达式的整型运算要在CPU的的相应运算元件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也还是CPU的通用寄存器的长度。
/// 因此，即使两个char类型的相加，在CPU执行时实际上也要先准换为CPU内整型操作数的标准长度。
/// 通用CPU(general-purpose CPU)是难以直接实现两个八比特字节直接相加运算的（虽然机器指令中可能有这种字节相加指令）。
/// 所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或者unsigned int，然后才能送去CPU进行运算。
/// 【如何进行整型提升】
/// 1.有符号的整型提升是按照变量的数据类型的符号位来提升的
/// 2.无符号整型提升，高位补0
//int main()
//{
//	char a = 5;
//	//00000000 00000000 00000000 00000101
//	//发生截断                   00000101
//	char b = 126;//同理
//	//                           01111110
//	//发生整型提升，默认有符号char，按照符号位提升
//	//00000000 00000000 00000000 00000101--a
//	//00000000 00000000 00000000 01111110--b
//	//结果00000000 00000000 00000000 10000011再次截断
//	//c--10000011
//	//%d导致整型提升11111111111111111111111110000011--补码
//	//原码：10000000000000000000000001111101==>>-125
//	char c = a + b;
//	printf("%d\n", c);
//	return 0;
//}

/// 【11.2】算数转换
/// 如果某个操作符的各个操作数属于不同的类型，除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为【寻常算术转换】
/// long double
/// double
/// float
/// unsigned long int 
/// long int 
/// int
/// 向上转换
/// 
/// 【11.3】.问题表达式解析
/// a*b+c*d+e*f
/// 这个表达式的问题在于，优先级不能保证第三个*比第一个+早计算，那么当其中字母代表函数的时候，并且随着调用顺序不同，结果也会不同的时候，就会产生误解，所以写表达式要减少这种不确定性
/// 
//int main()
//{
//	int c = 5;
//	int a = c + --c;//8=4+4?
//	printf("%d", a);
//	return 0;
//}

///《C和指针》有一个表达式在每一个编译器跑出来结果不一样。 
/// 【11.4】总结
/// 即使有了操作符的优先级和结合性，我们写出的表达式依然有可能不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在潜在风险（可能有bug）的，建议不要写出特别复杂的表达式。
/// 完结