//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
//#include <string.h>
//#include <Windows.h>
///【10.0】.C99中的变长数组
/// 在C99标准之前，C语言在创建数组的时候，数组大小的指定只能使用常量、常量表达式，或者如果我们初始化数据的话，可以省略数组的大小。
/// 如:
//int main()
//{
//	int arr1[10];
//	int arr2[2 + 5];
//	int arr2[] = { 1,2,3 };
//	return 0;
//}
/// 这样的语法限制让我们创建数组就不太灵活，有时候数组大了浪费空间，小了又不够用。
/// 于是，C99中给了一个变长数组（variable-length array,简称VLA）的新特性，允许我们可以使用变量指定数组的大小。
/// 如：
//int n = a+b;
//int arr[n];//但是，VS中不支持，devc++是可以的
//之所以VS不行，是因为默认使用微软自己的MSVC
// 使用clang就欧克了
//
///上面的实例中，arr就是变长数组，因为它的长度取决于变量n ，编译器没法事先确定，只有运行时才能知道n是多少。
/// 变长数组的【根本特征】，就是数组长度只有运行的时候才能确定，所以【变长数组不能初始化】。它的好处是程序员不必在开发时，随意为数组指定一个长度，程序可以在云巡视为数组分配精确的长度。
/// 迷惑的是，变长数组不代表数组长度可变，数组长度一经确定就不能改变了。
/// 【注意】OJ基本都支持变长数组

///【11.0】.数组练习
/// 【11.1】：字符串从两端向中间打印
/// 【示例】原文：welcome to bit!!!!!
///               *******************
///               w*****************!
///                    .......
/// 【补充】字符串数组的初始化
/// 1）char arr[]={'a','b'};
/// 2)char arr[]="ab";
//int main()
//{
//	char arr1[] = "welcome to bit!!!!!";
//	char arr2[] = "*******************";
//	int left = 0;
//	int right = (int)strlen(arr1) - 1;
//
//	while (left <= right)
//	{
//		arr2[left] = arr1[left];
//		arr2[right] = arr1[right];
//		printf("%s\n", arr2);
//		//Sleep(1000);//休眠函数，运行到此处程序暂停一段时间，单位：ms//【注意】S要大写
//		//system("cls");
//		left++;
//		right--;
//	}
//	//printf("%s\n", arr2);
//	return 0;
//}

///【10.2】：二分查找/折半查找
/// 在一个升序的数组中查找指定的数字n，很容易想到的方法是遍历数组，但是这种方法效率比较低下。
/// 二分查找就是查中位数
/// [遍历]
//int main()
//{
//	int k=7;
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz; i++)
//	{
//		if (arr[i] == k)
//		{
//			printf("找到了，下标是%d\n", i);
//			break;
//		}
//		if (i == sz)
//			printf("找不到");
//	}
//
//	return 0;
//}

//改进：二分法
//int main()
//{
//	int k = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int scan = scanf("%d", &k);
//	int sz = (int)sizeof(arr) / (int)sizeof(arr[0]);
//
//	int mid = 0, left = 0, right = sz - 1;
//	
//	do
//	{
//		mid = (left + right) / 2;
//		if (arr[mid] < k)
//		{
//			left = mid + 1;
//		}
//		else if (arr[mid] > k)
//		{
//			right = mid - 1;
//		}
//		else if (arr[mid] == k)
//		{
//			printf("找到了，下标是%d\n", mid);
//			break;
//		}
//	} while (arr[mid] != k&&left<=right);
//	if (left > right)
//	{
//		printf("找不到！\n");
//		//或者最开始假设一个变量flag为零表示找不到，也是可以的
//		//二分查找速度很快，但是条件也苛刻，必须是有序数组。
//	}
//	
//	return 0;
//}

//【注意】值得一提的是，如果right和left的值很大，求平均值就会出问题
//int main()
//{
//	int left = INT_MAX - 22;
//	int right = INT_MAX - 4;
//	//printf("%d", (left + right) / 2);//你会发现绝对出错了
//	//改进
//	//printf("%d", left + (right - left) / 2);
//	return 0;
//}

///【第六讲】函数
/// 【1.0】.函数的概念
/// 其实C语言中的函数（function）和数学中的函数不太一样，有些翻译为：子程序，这种翻译更为准确。C语言中的函数就是一个完成某项待定任务的一段代码，这段代码有特定的写法和调用方式。
/// C语言的程序其实是由无数个小函数组合而成，也可以说：一个大的计算任务可以分解成若干个较小的函数（对应较小的任务）完成。同时，一段完成某项特定任务的代码可以被快速引用，也是函数的意义之一。
/// 在C中有两类函数，库函数和自定义函数。
/// 
/// 【2.0】.库函数
/// 【2.1】.标准库和头文件
/// C语言标准中规定了C语言的各种语法规则，C语言并不提供库函数；C语言的国际标准ANSI C规定了一些常用的函数的标准，称为标准库，那些不同的编译器厂商根据ANSI提供的C语言标准就给出了，一系列函数的实现
/// 这些函数就被称为【库函数】，这些库函数根据功能的划分，都在不同的头文件中进行了声明，使用之前务必包含头文件，不然可能出错。
/// 库函数相关头文件：https://en.cppreference.com/w/c/header
/// 有数学相关的，字符串相关的，日期相关的，每一个头文件中都包含了相关的函数和类型等信息，库函数的学习不必着急一次性学完，慢慢学习，逐个突破就行。
/// 【2.2】.库函数的使用方法
/// 库函数的学习和查看工具很多，比如：
/// C/C++官方：https://en.cppreference.com/w/c/header
/// cplusplus.com:  https://legacy.cplusplus.com/reference/clibrary
/// 【注意】en代表英文版本    zh代表中文版本 
/// 【2.2.1】库函数文档的一般格式
/// 1.函数原型
/// 2.函数功能介绍
/// 3.参数和返回类型说明
/// 4.代码举例
/// 5.代码输出
/// 6.相关知识链接
/// 
/// 【3.0】.自定义函数
/// 了解了库函数，我们的关注度应该聚焦在自定义函数上，它更加重要，也能给程序员写代码更多的创造性。
/// 【3.1】.函数的语法形式
/// 形式如下：
///		ret_type fun_name(形式参数)
///		{
///			函数体
///		}
/// 【说明】ret_type代表函数计算结果的类型，有时候返回类型可以是void表示什么都不会返回
///			fun_name就是函数名是为了使用才取的，调用的时候直接叫其名，一般要根据其功能来取一个有意义的名字。
/// 【3.2】.函数的举例
/// 写一个加法函数,完成两个整型变量的加法操作
//int Add(int a, int b)
//{
//	return a + b;
//}
//int main()
//{
//	int n1 = 0;
//	int n2 = 0;
//	scanf("%d %d", &n1, &n2);
//	//写一个加法函数
//	int r = Add(n1, n2);
//	printf("%d", r);
//	return 0;
//}

/// 【4.0】.形参和实参
/// 在函数调用的时候，实际传输给函数的参数就是实参
/// 函数定义的时候，括号里面的参数就是形参（形式参数），因为压根就没有给他们分配空间，直到给他传输数据的时候才会分配内存。。（返回值-->寄存器-->函数值）
/// 形参是实参的一份临时拷贝
/// 形参有自己的独立空间
/// 对形参的修改不会影响实参
/// 【注意】形参的名字和实参可以相同
/// 
/// 【5.0】.return语句
/// 在函数的设计中，经常出现这个语句，这里讲一下其注意事项：
/// return后面可以是一个数值也可以是一个表达式，如果是表达式则先运算表达式再返回表达式的结果。
/// return后面可以直接；，这种写法适合函数返回类型是void的情况
/// return返回的值和返回类型不匹配，系统会自动将返回值隐式强行转化为函数的返回类型。
/// return语句执行后，函数就彻底返回，后面的代码不再执行。
/// 如果函数中存在if等分支语句，则要保证每种情况下都有return返回，否则会出现编译错误。
/// main函数也是函数，其返回值被编译器指定的一个函数调用了，返回0则正常，非零则异常。
/// 
/// 【6.0】.数组作为函数参数
/// 在使用函数解决问题的时候，难免会将数组作为参数传递给函数，在函数内部对数组进行操作。
/// 比如：写个函数将一个整型数组的内容，全部重置为-1，再写一个函数打印数组内容。
//void set(int arr[], int sz)
//{
//	int i = 0;
//	for (; i < sz; i++)
//	{
//		arr[i] = -1;
//	}
//}
//void print(int arr[],int sz)
//{
//	int i = 0;
//	for (i=0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = (int)sizeof(arr) / (int)sizeof(arr[0]);
//	//写个函数将一个整型数组的内容，全部重置为-1
//	set(arr, sz);
//	print(arr, sz);
//	return 0;
//}
//注意】：为什么要把sz求好再传进去？？因为函数里面是求不到的，我们说过传参传进去的是地址，即数组在传参过程中会发生降级变成一个地址，看着像数组，其实是地址。
/// 【疑惑】为什么形参数组不指定大小？数组传参其实传递的是数组的地址，形参部分访问数组的时候，其实操作的就是主调函数中的数组，形参不会新建一个数组，所以也就不需要指定一个大小
/// 【补充】：
/// 形参如果是一维数组，数组大小可不写
/// 形参如果是二维数组，行可以省，列不行。
/// 数组传参，形参不会创建新数组，二者操作的是一个数组，同一个地址。