//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
//#include <string.h>

///第11讲 ：深入理解指针（1）
/// 其实在指针的学习中：
/// 1.是一个个知识点
/// 2.重在理解
/// 3.不要怕，放下恐惧
/// 【*****指针*****】
/// 
/// 【1.0】内存和地址
/// 【1.1】内存
/// 计算机的CPU（中央处理器）在处理数据时，需要的数据是从内存中读取的，处理后的数据又会放回到内存中，如何高效管理内存呢？答案是将其划分为一个个内存单元，每个内存单元的大小取一个字节，我们给每个单元取一个编号，通俗意义上的地址，这就是指针
/// 可以理解为：内存单元的编号==地址==指针
/// 【补充】计算机中的常见单位
/// 一个比特位可以存储一个二进制位，一个字节可以存8个比特位
/// 1KB=1024Byte
/// 1MB=1024KB
/// 1GB=1024MB
/// 1TB=1024GB
/// 1PB=1024TB
/// 【1.2】.究竟如何理解编址
/// 首先，必须理解计算机内部有很多硬件单元，他们之间互相协同，那么至少相互之间要能够进行数据的传递。
/// 所以，在CPU和内存之间就有很多的“线”，如数据总线、控制总线，但今天我们只关注一组---地址总线
/// 计算机中的编址，不是真的给每个字节编码后记录下来，而是通过硬件设计实现的。
/// 我们可以简单理解，32位机器有32根地址总线，每根线只有两态，表示0/1【电脉冲有无】，那么一根线就能表达两种含义，32根线就能表达2^32种含义，每一种含义都代表一个地址。
/// 地址信息被下达给内存，在内存上，就可以找到该地址对应的数据，将数据通过数据总线传入CPU内寄存器。
/// 【2.0】指针变量和地址
/// 【2.1】取地址操作符（&）
/// 在C语言中，创建变量其实就是向内存申请空间，比如：
/// int a创建了整型变量a，向内存申请了四个字节，每个字节都有一个地址
/// &a取出的是a所占字节中地址较小的字节地址。
/// 【2.2】指针变量和解引用操作符（*）
/// 【2.2.1】指针变量
/// 我们通过取地址操纵符拿到的地址是一个数值，这个数值有时候也需要存起来，方便后期再使用的，那我们把这样的地址值存在哪里？答案是：指针变量
/// 指针变量也是一种变量，这种变量就是用来存放地址的，存放在指针变量中的值都会被理解为地址。
//int main()
//{
//	int n = 0;
//	char ch = 'w';
//	//pn就被称为指针变量
//	int * pn = &n;//也可以写作int*
//	char* pc = &ch;
//	return 0;
//}
/// 【2.2.2】如何拆解指针类型
/// pn指向n，表示地址
/// int *应该分开理解1）*代表是指针变量2）int表明pn指向的类型是整型
/// 【2.2.3】解引用操作符（*）
/// 
//int main()
//{
//	int n = 20;
//	int * pn = &n;
//
//	//解引用操作符/间接引用操作符
//	//你会发现*和&是逆过程
//	*pn = 30;//这个等效于n=30，有没有感觉这种操作是脱裤子放屁
//	//解释合理性：1）解决问题途径的多样性，会让代码更加灵活；2）有时候可能用n不方便，就交给pn去完成
//	printf("%d", n);
//	return 0;
//}
/// 【2.3】指针变量的大小
/// 由前面的知识我们了解到，32位机器假设有32根地址总线，每根地址总线出来的电信号转换成数字信号后就是0或者1，那么我们把322根地址总线产生的二进制序列当作一个地址，那么一个地址就是32个比特位，需要4个字节的空间才能存储。
/// 同理64位机器就要8字节
/// 即：指针变量的大小取决于地址大小，32位系统==》4byte；64位系统==》8byte
/// 可以通过以下代码验证
//int main()
//{
//	int n = 20;
//	int* pn = &n;
//	printf("%d",sizeof(pn));
//	return 0;
//}
///【注意】指针变量的大小和类型无关，只要是指针变量，在相同环境下，大小相同
/// 【3.0】指针变量类型的意义
/// 既然指针变量的大小和类型无关,那为什么还要设置指针类型呢？
/// 其实指针类型是有特殊意义的，接下来的内容中会讲到。
/// 【3.1】指针的解引用
///通过以下代码观察内存，可以分析出一些东西：
//int main()
//{
//	int n = 0x11223344;
//	int* pn = &n;
//	*pn = 0;//四列（字节）全部改变
//	n = 0x11223344;
//	char* pc = &n;
//	*pc = 0;//只改变了一个字节
//
//	return 0;
//}
///在这个地方，指针类型决定了一件事情：在对指针进行解引用操作的时候访问几个字节。
/// 比如这里：int*---四个字节    char*---一个字节
/// 【结论】指针类型决定了，对指针解引用的时候有多大权限（一次能操作几个字节）
/// 
/// 【3.2】指针+-整数
//int main()
//{
//	int n = 0x11223344;
//	int* pi = &n;
//	char* pc = &n;
//
//	printf("&n=%p\n", &n);
//	printf("pi  =%p\n", pi);
//	printf("pi+1=%p\n", pi+1);//地址变化4（字节）
//
//	printf("pc  =%p\n", pc);
//	printf("pc+1=%p\n", pc+1);//地址变化1（字节）
//	return 0;
//}
///【结论】指针类型决定了指针向前或者向后移动一步的步距。 
/// 【3.3】void*指针
/// 这是一种特别的指针，表示无具体类型的指针（泛型指针），可以接收任意类型的地址，但是其局限性是不能直接进行指针的+-整数和解引用运算，如果要使用，就通过强制类型转换变成想要的类型
//int main()
//{
//	int n = 10;
//	void* pn = &n;
//	*(int*)pn = 2;
//	printf("%d\n", n);
//	return 0;
//}
/// 都知道void*类型的指针可以接受不同类型的地址，但是无法直接进行指针运算
/// 那它到底有什么用？
/// 一般使用在函数参数的部分，用来接收不同数据类型的地址，这样的设计，可以实现泛型编程的效果，使得一个函数可以处理多种类型的数据，在深入理解指针（4）会说到。
/// 【4.0】const修饰指针
/// 【4.1】const修饰变量
//int main()
//{
//	int num = 0;
//	num = 20;
//	printf("%d\n", num);
//	const int s = 0;//const使得s具有常属性：不可修改，只能读取，还是（常）变量
//	//在C语言中，这s是常变量，本质上是变量，只因有const修饰，编译器在语法上不允许修改这个变量
//	// 但是在C++中，这个s就是常量。（进一步讲，在cpp中就可以利用这个性质实现变长数组）
//	//s = 20;这个时候s是无法修改的
//
//	return 0;
//}
///【补充】通过指针可以更改const修饰的变量
//int main()
//{
//	const int n = 0;
//	int* p = &n;
//	*p = 1;
//	printf("%d", n);
//
//	return 0;
//}
///其实你会发现这样的操作就是在违逆代码的意志，不让你改，你非改。
/// 下面，我们即讲到如何限制指针
/// 【4.2】const修饰指针变量
/// 有两种情况：
/// 1】const int * p==int const * p（放*左边）
/// 表示不能通过【这个指针变量】的解引用来修改它指向的地址存储的数据，但不代表这个变量不能修改，也不代表地址上存储的数据不能修改，仍然可以通过其他指针变量来修改。
//int main()
//{
//	const int num = 10;
//	int const* p = &num;
//	int* pp = p;
//	*pp = 20;
//	printf("%d", num);
//	return 0;
//}
/// 2】int * const（放*右边）
///表示这个指针变量本身不能修改
//int main()
//{
//	int num = 10;
//	int* const p = &num;
//	p = 20;
//	printf("%d", num);
//	return 0;
//}
/// 【5.0】指针运算
/// 指针的基本运算有3种
/// 【指针+-整数】
/// 打印一维数组所有元素
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = &arr[0];
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//
//	for (; i < sz; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	return 0;
//}
/// 【指针-指针】
/// 运算的前提是：两个2指针指向同一空间
/// 结果的绝对值是地址之间的元素个数，有正负,类型是long long int，对应占位符%lld
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%lld\n", &arr[0] - &arr[9]);
//	return 0;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = "abcdef";
//	printf("%zd\n", sizeof(ch));//求的是大小
//	printf("%zd\n", strlen(ch));//求的是字符串中\0之前的字符个数
//	return 0;
//}
///version1
//size_t my_strlen(char* s)
//{
//	size_t count = 0;
//	while (*s != '\0')
//	{
//		count++;
//		s++;
//	}
//	return count;
//}
///version2
//size_t my_strlen(char* s)
//{
//	char* start = s;
//	while (*s != '\0')
//	{
//		s++;
//	}
//	char* end = s;
//	return ((size_t)(end - start));
//}
//
//int main()
//{
//	char ch[10] = "abcdef";
//	size_t len = my_strlen(ch);//数组名其实是数组首元素的地址
//	printf("%zd", len);
//	return 0;
//}
/// 【指针的关系运算】
/// 就是两个地址比较大小

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//使用指针的关系运算来打印数组的内容
//	int* p = arr;
//	int sz = sizeof(arr) / sizeof(arr[0]);//10
//	while (p < &arr[sz])
//	{
//		printf("%d\n", *p);
//		p++;
//	}
//
//	return 0;
//}
//可以试试倒序输出

/// 【6.0】野指针
/// 概念：野指针就是指针指向的位置是不可知的（随机的、不确定的、没有明确限制的）
/// 【6.1】野指针成因
/// 1】指针未初始化

//int main()
//{
//	int* p;//p没有初始化，（局部变量）值是随机的
//	*p = 20;//非法访问，p就是野指针
//	return 0;
//}

/// 2】指针越界访问

//int main()
//{
//	int arr[10] = { 0 };
//	int* p = &arr[0];
//	int i = 0;
//	for (; i <= 11; i++)
//	{
//		//当指针指向的范围超出arr的范围时，p就是野指针
//		*(p++) = i;
//	}
//	return 0;
//}

///3】指针指向的空间释放了

//int* test()
//{
//	int n = 100;
//	return &n;
//}
//int main()
//{
//	int* p = test();
//	printf("%d\n", *p);
//	return 0;
//}

///【6.2】如何规避野指针
/// 【6.2.1】指针初始化
/// 如果明确知道指针指向哪里就直接赋值地址，如果不知道，可以给指针赋值NULL
/// NULL是C语言中定义的一个标识符常量，值是0，0也是地址，这个地址是无法使用的，读写该地址会报错。

//int main()
//{
//	int* p = NULL;
//	*p = 20;
//	return 0;
//}

///【6.2.2】小心指针越界
///【6.2.3】指针变量不再使用时，及时置NULL，指针使用之前检查有效性（是否为NULL）[if(p != NULL)]
///【6.2.4】避免返回局部变量的地址
/// 【7.0】assert断言
/// assert.h头文件定义了宏assert()，用于在运行时确保程序符合指定条件，如果不符合，就报错终止运行。这个宏常常被称为“断言”
/// [assert(p != NULL);]
//#define ndebug
#include <assert.h>

//int main()
//{
//	int* p = NULL;
//	assert(p != NULL);
//	return 0;
//}

///assert（）宏接收一个表达式作为参数。如果真，不会有影响；如果假，assert就会报错，在标准错误流stderr中写入一条错误信息，显示没有通过的表达式，以及包含这个表达式的文件名和行号。
/// 此外，它还有一种无需修改代码就能开启或者关闭assert的机制：如果已经确定程序没有问题，不需要再做断言，就在#include <assert>语句的前面，定义一个宏NDEBUG。
/// 然后，重新编译程序，编译器就会禁用文件中所有的assert语句。如果要恢复，就把宏注释掉。当然assert的缺点是，因为引入了额外的检查，增加了程序的运行时间。
/// 【8.0】指针的使用和传址调用
/// 【8.1】strlen的模拟实现(改进)
//my_strlen(const char* s)//加const防止不小心修改*s
//{
//	size_t count = 0;
//	assert(s != NULL);
//	while (*s)//\0的ASCII码居然就等于0！
//	{
//		count++;
//		s++;
//	}
//	return count;
//}
//int main()
//{
//	char arr[] = "abcdef";
//	size_t len = my_strlen(arr);
//	printf("%zd", len);
//	return 0;
//}

/// 【8.2】传值调用和传址调用
///我们学习指针就是为了解决一些非指针不可的问题，那么它可以干嘛？
/// 【例子】写一个函数，交换两个整型变量的值

//void swap(int x, int y)
//{
//	int z = 0;
//	z = x;
//	x = y;
//	y = z;
//
//}
//int main()
//{
//	int a = 0, b = 0;
//	scanf("%d %d", &a, &b);
//	printf("交换前：a=%d, b=%d\n", a, b);
//
//	swap(a, b);
//	printf("交换后：a=%d, b=%d\n", a, b);
//	return 0;
//}

///你会发现没有交换成功，那是因为函数是传值调用，形参和实参地址不一样，他们有各自独立的空间，形参不能影响实参。
///下面我们改写以下，借助指针：
//void swappro(int* pa, int* pb)
//{
//	int z = 0;
//	z = *pa;
//	*pa = *pb;
//	*pb = z;
//}
//
//void swap(int* pa, int* pb)
//{
//	*pa = *pa ^ *pb;
//	*pb = *pa ^ *pb;
//	*pa = *pa ^ *pb;
//}
//int main()
//{
//	int a = 0, b = 0;
//	scanf("%d %d", &a, &b);
//	printf("交换前：a=%d, b=%d\n", a, b);
//
//	swap(&a, &b);
//
//	printf("交换后：a=%d, b=%d\n", a, b);
//
//	return 0;
//}
///这就是所谓“传址调用”，只有这种调用才能让函数内部和函数外部（主调函数）建立起真正的联系。